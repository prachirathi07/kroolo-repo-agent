from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import Response
from app.core.database import get_db
from app.schemas.schemas import DocumentationResponse, DocumentationVersionList
from app.core.logger import logger

router = APIRouter()


@router.get("/{repo_id}", response_model=DocumentationResponse)
async def get_latest_documentation(repo_id: str, db = Depends(get_db)):
    """
    Get latest documentation for a repository
    """
    # Check if repository exists
    repo_response = db.table("repositories").select("id").eq("id", repo_id).execute()
    if not repo_response.data:
        raise HTTPException(status_code=404, detail="Repository not found")
    
    # Get latest documentation
    response = db.table("documentation").select("*").eq("repo_id", repo_id).order("version", desc=True).limit(1).execute()
    
    if not response.data:
        raise HTTPException(status_code=404, detail="Documentation not found")
    
    return response.data[0]


@router.get("/{repo_id}/versions", response_model=DocumentationVersionList)
async def get_documentation_versions(
    repo_id: str,
    skip: int = 0,
    limit: int = 10,
    db = Depends(get_db)
):
    """
    Get all documentation versions for a repository
    """
    response = db.table("documentation").select("*", count="exact").eq("repo_id", repo_id).order("version", desc=True).range(skip, skip + limit - 1).execute()
    
    versions = response.data
    total = response.count or 0
    
    return DocumentationVersionList(
        versions=versions,
        total=total
    )


@router.get("/{repo_id}/export/markdown")
async def export_markdown(repo_id: str, db = Depends(get_db)):
    """
    Export documentation as Markdown
    """
    response = db.table("documentation").select("*").eq("repo_id", repo_id).order("version", desc=True).limit(1).execute()
    
    if not response.data:
        raise HTTPException(status_code=404, detail="Documentation not found")
    
    doc = response.data[0]
    
    # Get repository info
    repo_response = db.table("repositories").select("*").eq("id", repo_id).execute()
    repo = repo_response.data[0]
    
    # Generate Markdown
    content = doc['content']
    markdown = f"""# {repo['name']}

{content.get('executive_summary', '')}

## Product Overview

{content.get('product_overview', '')}

## Key Features

{chr(10).join(f"- {feature}" for feature in content.get('key_features', []))}

## Technology Stack

### Languages
{', '.join(content.get('tech_stack', {}).get('languages', []))}

### Frameworks
{', '.join(content.get('tech_stack', {}).get('frameworks', []))}

### Databases
{', '.join(content.get('tech_stack', {}).get('databases', []))}

## Architecture

```mermaid
{content.get('architecture', '')}
```

## Use Cases

{chr(10).join(f"{i+1}. {uc}" for i, uc in enumerate(content.get('use_cases', [])))}

## Integrations

{chr(10).join(f"- {integration}" for integration in content.get('integrations', []))}

## Marketing Talking Points

{chr(10).join(f"- {point}" for point in content.get('marketing_points', []))}

---

*Generated by RepoDocAgent*
*Repository: {repo['url']}*
*Commit: {doc['commit_hash']}*
*Files Analyzed: {doc['file_count']}*
*Lines of Code: {doc['lines_of_code']}*
"""
    
    filename = f"{repo['name']}_documentation.md" if repo['name'] else "documentation.md"
    
    return Response(
        content=markdown,
        media_type="text/markdown",
        headers={
            "Content-Disposition": f"attachment; filename={filename}"
        }
    )


@router.get("/{repo_id}/export/json")
async def export_json(repo_id: str, db = Depends(get_db)):
    """
    Export documentation as JSON
    """
    response = db.table("documentation").select("*").eq("repo_id", repo_id).order("version", desc=True).limit(1).execute()
    
    if not response.data:
        raise HTTPException(status_code=404, detail="Documentation not found")
    
    doc = response.data[0]
    
    repo_response = db.table("repositories").select("*").eq("id", repo_id).execute()
    repo = repo_response.data[0]
    
    export_data = {
        "repository": {
            "name": repo['name'],
            "url": repo['url'],
            "description": repo['description']
        },
        "documentation": doc['content'],
        "metadata": {
            "version": doc['version'],
            "commit_hash": doc['commit_hash'],
            "file_count": doc['file_count'],
            "lines_of_code": doc['lines_of_code'],
            "generated_at": doc['created_at']
        }
    }
    
    return export_data


@router.get("/{repo_id}/export/docx")
async def export_docx(repo_id: str, db = Depends(get_db)):
    """
    Export documentation as DOCX
    """
    from docx import Document
    from docx.shared import Pt, Inches
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    import io
    from fastapi.responses import StreamingResponse

    # Fetch Data
    response = db.table("documentation").select("*").eq("repo_id", repo_id).order("version", desc=True).limit(1).execute()
    
    if not response.data:
        raise HTTPException(status_code=404, detail="Documentation not found")
    
    doc = response.data[0]
    content = doc['content']
    
    repo_response = db.table("repositories").select("*").eq("id", repo_id).execute()
    repo = repo_response.data[0]
    repo_name = repo.get('name') or "Repository"

    # Create Document
    document = Document()
    
    # Title
    title = document.add_heading(repo_name, 0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    document.add_paragraph(f"Repository Documentation generated by RepoDocAgent")
    document.add_paragraph(f"Source: {repo.get('url', '')}")
    document.add_paragraph(f"Version: {doc.get('version', 1)} | Commit: {doc.get('commit_hash', 'unknown')[:7]}")
    document.add_page_break()

    # Executive Summary
    document.add_heading('Executive Summary', level=1)
    document.add_paragraph(content.get('executive_summary', ''))

    # Product Overview
    document.add_heading('Product Overview', level=1)
    document.add_paragraph(content.get('product_overview', ''))

    # Key Features
    document.add_heading('Key Features', level=1)
    features = content.get('key_features', [])
    for feature in features:
        document.add_paragraph(feature, style='List Bullet')

    # Tech Stack
    document.add_heading('Technology Stack', level=1)
    tech_stack = content.get('tech_stack', {})
    
    if tech_stack.get('languages'):
        document.add_heading('Languages', level=2)
        document.add_paragraph(", ".join(tech_stack.get('languages', [])))
        
    if tech_stack.get('frameworks'):
        document.add_heading('Frameworks', level=2)
        document.add_paragraph(", ".join(tech_stack.get('frameworks', [])))
        
    if tech_stack.get('databases'):
        document.add_heading('Databases', level=2)
        document.add_paragraph(", ".join(tech_stack.get('databases', [])))

    # Use Cases
    document.add_heading('Use Cases', level=1)
    use_cases = content.get('use_cases', [])
    for i, uc in enumerate(use_cases):
        document.add_paragraph(uc, style='List Number')

    # Integrations
    document.add_heading('Integrations', level=1)
    integrations = content.get('integrations', [])
    for integration in integrations:
        document.add_paragraph(integration, style='List Bullet')
        
    # Marketing Points
    document.add_heading('Marketing Talking Points', level=1)
    marketing = content.get('marketing_points', [])
    for point in marketing:
        document.add_paragraph(point, style='List Bullet')

    # Save to memory
    file_stream = io.BytesIO()
    document.save(file_stream)
    file_stream.seek(0)
    
    filename = f"{repo_name.replace(' ', '_')}_documentation.docx"
    
    return StreamingResponse(
        file_stream,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


